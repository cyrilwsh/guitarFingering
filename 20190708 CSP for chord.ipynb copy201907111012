{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "CSP - constraint satiscation problem\n",
    "for Chord fingering"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "capo = 0\n",
      "tuning = [64, 59, 55, 50, 45, 40]\n",
      "Notes in Finger board:\n",
      "string 1 to 6\n",
      "[64, 59, 55, 50, 45, 40]\n",
      "[65, 60, 56, 51, 46, 41]\n",
      "[66, 61, 57, 52, 47, 42]\n",
      "[67, 62, 58, 53, 48, 43]\n",
      "[68, 63, 59, 54, 49, 44]\n",
      "[69, 64, 60, 55, 50, 45]\n",
      "[70, 65, 61, 56, 51, 46]\n",
      "[71, 66, 62, 57, 52, 47]\n",
      "[72, 67, 63, 58, 53, 48]\n",
      "[73, 68, 64, 59, 54, 49]\n",
      "[74, 69, 65, 60, 55, 50]\n",
      "[75, 70, 66, 61, 56, 51]\n",
      "[76, 71, 67, 62, 57, 52]\n"
     ]
    }
   ],
   "source": [
    "from funcMidi import funcCreatNoteDic\n",
    "dicNoteOnFingerBoard = funcCreatNoteDic()\n",
    "# funcCreatNoteDic(2, [64, 59, 55, 50, 45, 30])\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 67,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[[[6, 1, 1], [6, 1, 2], [6, 1, 3], [6, 1, 4]],\n",
       " [[5, 3, 1],\n",
       "  [5, 3, 2],\n",
       "  [5, 3, 3],\n",
       "  [5, 3, 4],\n",
       "  [6, 8, 1],\n",
       "  [6, 8, 2],\n",
       "  [6, 8, 3],\n",
       "  [6, 8, 4]],\n",
       " [[4, 3, 1],\n",
       "  [4, 3, 2],\n",
       "  [4, 3, 3],\n",
       "  [4, 3, 4],\n",
       "  [5, 8, 1],\n",
       "  [5, 8, 2],\n",
       "  [5, 8, 3],\n",
       "  [5, 8, 4]]]"
      ]
     },
     "execution_count": 67,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "choCombination = [dicNoteOnFingerBoard[43], dicNoteOnFingerBoard[47]]\n",
    "# print(dicNoteOnFingerBoard[43]) # G2\n",
    "# print(dicNoteOnFingerBoard[47]) # B2\n",
    "\n",
    "# choNote = [41, 48, 52, 56, 60, 65]\n",
    "choNote = [41, 48, 53]\n",
    "\n",
    "domains = []\n",
    "x = 0 # variable\n",
    "for x in range(len(choNote)):\n",
    "    # x = 41\n",
    "    domains.append([])\n",
    "    fingerings = dicNoteOnFingerBoard[choNote[x]]\n",
    "    # fingerings = [[5, 2], [6, 7]]\n",
    "    for fingering in fingerings:\n",
    "        # fingering = [5,2]\n",
    "        if fingering[1] == 0: # if fret=0, no need swap all fingers\n",
    "            domains[x].append(fingering + [0])\n",
    "        else: # if fret !=0, swap all fingers 1~4\n",
    "            for finger1234 in range (1,5):\n",
    "#                 print(finger1234)\n",
    "                domains[x].append(fingering + [finger1234])\n",
    "#     csp[x] = \n",
    "    # [\n",
    "    #    [[6,3,1], [6,3,2], [6,3,3], [6,3,4]],\n",
    "    #    [[5,2,1], [5,2,2], [5,2,3], [5,2,4], [6,7,1], [6,7,2], [6,7,3], [6,7,4]],\n",
    "    # ]\n",
    "\n",
    "domains"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 86,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[[6, 1, 1], [6, 1, 2], [6, 1, 3], [6, 1, 4]], [[5, 3, 1], [5, 3, 2], [5, 3, 3], [5, 3, 4], [6, 8, 1], [6, 8, 2], [6, 8, 3], [6, 8, 4]], [[4, 3, 1], [4, 3, 2], [4, 3, 3], [4, 3, 4], [5, 8, 1], [5, 8, 2], [5, 8, 3], [5, 8, 4]]]\n",
      "3\n",
      "0 0 1 1 case5\n",
      "[6, 1, 1]\n",
      "[5, 3, 2]\n",
      "1\n",
      "0 0 2 1 case5\n",
      "[6, 1, 1]\n",
      "[4, 3, 2]\n",
      "2\n",
      "3\n",
      "4\n",
      "5\n",
      "6\n",
      "7\n",
      "8\n",
      "9\n",
      "10\n",
      "11\n",
      "12\n",
      "13\n",
      "14\n",
      "15\n",
      "16\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "[[1, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1, 1, 1]]"
      ]
     },
     "execution_count": 86,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# domains.append([22,33,44])\n",
    "\n",
    "\n",
    "useFlag = list.copy(domains)\n",
    "print(useFlag)\n",
    "i = 0\n",
    "for i in range(len(useFlag)):\n",
    "    useFlag[i] = [0]*(len(useFlag[i]))\n",
    "        \n",
    "\n",
    "        \n",
    "def dicAppend(key, value, dic):\n",
    "    useFlag[dn][pn] = 1\n",
    "    useFlag[sdn][spn] = 1\n",
    "    if key in dic:\n",
    "        dic[key].append(value)\n",
    "    else:\n",
    "        dic[key] = [value]\n",
    "\n",
    "        \n",
    "dicCombination = {} # \"legal\" combinations after DPC algorithm\n",
    "# listCombination = [] # \"legal\" combinations after DPC algorithm\n",
    "# countComb = 0\n",
    "\n",
    "dn = 0 # domain number\n",
    "\n",
    "print(len(domains))\n",
    "for dn in range(len(domains) -1): # domain number\n",
    "    for pn in range(len(domains[dn])): # position number\n",
    "        # sdn: sub-domain number, starting from the next domain\n",
    "        for sdn in range(dn+1, len(domains)): \n",
    "            \n",
    "            for spn in range(len(domains[sdn])):\n",
    "#                 print(str(dn) + \" \" + str(pn) +\" \" + str(sdn) + \" \" + str(spn) + \" \" +\"case 1\")\n",
    "#                 print(\"case 1\")\n",
    "                # constraints\n",
    "\n",
    "#                 # c0: see this position is already been justified as usable, then skip\n",
    "#                 if useFlag[dn][pn]==1 and useFlag[sdn][spn]==1:\n",
    "#                     print(str(dn) + \" \" + str(pn) +\" \" + str(sdn) + \" \" + str(spn) + \" \" +\"case 2\")\n",
    "#                      break\n",
    "                string0 = domains[dn][pn][0]\n",
    "                string1 = domains[sdn][spn][0]\n",
    "                # c1: one note per string\n",
    "                if string0 != string1:\n",
    "#                     print(str(dn) + \" \" + str(pn) +\" \" + str(sdn) + \" \" + str(spn) + \" \" +\"case 3\")\n",
    "                    finger0 = domains[dn][pn][2]\n",
    "                    finger1 = domains[sdn][spn][2]\n",
    "                    fret0 = domains[dn][pn][1]\n",
    "                    fret1 = domains[sdn][spn][1]\n",
    "                    fingerDiff = finger0 - finger1 # finger difference\n",
    "                    absFingerDiff = abs(fingerDiff)\n",
    "                    fretDiff = fret0 - fret1\n",
    "                    absFretDiff = abs(fretDiff)\n",
    "                    \n",
    "\n",
    "                    # c4*: the same fret\n",
    "                    if fret0 == fret1:\n",
    "                        #  c4: barre index\n",
    "                        if finger0 == finger1 ==1:\n",
    "#                         print(str(dn) + \" \" + str(pn) +\" \" + str(sdn) + \" \" + str(spn) + \" \" +\"case4\")\n",
    "                            dicAppend((dn,sdn),(domains[dn][pn], domains[sdn][spn]),dicCombination)\n",
    "                        # c4-1: same fret: lower finger press higher \"strings\"\n",
    "                        elif (string0 - string1)*(finger0 - finger1) < 0:\n",
    "                            dicAppend((dn,sdn),(domains[dn][pn], domains[sdn][spn]),dicCombination)\n",
    "                    \n",
    "                    # c2: higher finger press higher frets\n",
    "                    #     finger0 is stronger\n",
    "                    elif finger0 == 1:\n",
    "                        if finger1 == 2 and 0 < (-fretDiff) <= 2:\n",
    "                            print(str(dn) + \" \" + str(pn) +\" \" + str(sdn) + \" \" + str(spn) + \" \" +\"case5\")\n",
    "                            print(domains[dn][pn])\n",
    "                            print(domains[sdn][spn])\n",
    "                            dicAppend((dn,sdn),(domains[dn][pn], domains[sdn][spn]),dicCombination)\n",
    "                        elif finger1 == 3 and 0 < (-fretDiff) <= 3:\n",
    "#                             print(str(dn) + \" \" + str(pn) +\" \" + str(sdn) + \" \" + str(spn) + \" \" +\"case6\")\n",
    "\n",
    "                            dicAppend((dn,sdn),(domains[dn][pn], domains[sdn][spn]),dicCombination)\n",
    "                        elif finger1 == 4 and 0 < (-fretDiff) <= 4:\n",
    "#                             print(str(dn) + \" \" + str(pn) +\" \" + str(sdn) + \" \" + str(spn) + \" \" +\"case7\")\n",
    "                            dicAppend((dn,sdn),(domains[dn][pn], domains[sdn][spn]),dicCombination)\n",
    "                    elif finger0 == 2:\n",
    "                        if finger1 == 3 and 0 < (-fretDiff) <= 1:\n",
    "#                             print(str(dn) + \" \" + str(pn) +\" \" + str(sdn) + \" \" + str(spn) + \" \" +\"case8\")\n",
    "                            dicAppend((dn,sdn),(domains[dn][pn], domains[sdn][spn]),dicCombination)\n",
    "                        elif finger1 == 4 and 0 < (-fretDiff) <= 3:\n",
    "#                             print(str(dn) + \" \" + str(pn) +\" \" + str(sdn) + \" \" + str(spn) + \" \" +\"case9\")\n",
    "                            dicAppend((dn,sdn),(domains[dn][pn], domains[sdn][spn]),dicCombination)\n",
    "                    elif finger0 == 3:\n",
    "                        if finger1 == 4 and 0 < (-fretDiff) <= 1:\n",
    "#                             print(str(dn) + \" \" + str(pn) +\" \" + str(sdn) + \" \" + str(spn) + \" \" +\"case10\")\n",
    "                            dicAppend((dn,sdn),(domains[dn][pn], domains[sdn][spn]),dicCombination)\n",
    "                            \n",
    "                    # when finger1 stronger than finger0\n",
    "                    elif finger1 == 1:\n",
    "                        if finger0 == 2 and 0 < (fretDiff) <= 2:\n",
    "#                             print(str(dn) + \" \" + str(pn) +\" \" + str(sdn) + \" \" + str(spn) + \" \" +\"case11\")\n",
    "                            dicAppend((dn,sdn),(domains[dn][pn], domains[sdn][spn]),dicCombination)\n",
    "                            \n",
    "                        elif finger0 == 3 and 0 < (fretDiff) <= 3:\n",
    "#                             print(str(dn) + \" \" + str(pn) +\" \" + str(sdn) + \" \" + str(spn) + \" \" +\"case12\")\n",
    "                            dicAppend((dn,sdn),(domains[dn][pn], domains[sdn][spn]),dicCombination)\n",
    "                            \n",
    "                        elif finger0 == 4 and 0 < (fretDiff) <= 4:\n",
    "#                             print(str(dn) + \" \" + str(pn) +\" \" + str(sdn) + \" \" + str(spn) + \" \" +\"case13\")\n",
    "                            dicAppend((dn,sdn),(domains[dn][pn], domains[sdn][spn]),dicCombination)\n",
    "                            \n",
    "                    elif finger1 == 2:\n",
    "                        if finger0 == 3 and 0 < (fretDiff) <= 1:\n",
    "#                             print(str(dn) + \" \" + str(pn) +\" \" + str(sdn) + \" \" + str(spn) + \" \" +\"case14\")\n",
    "                            dicAppend((dn,sdn),(domains[dn][pn], domains[sdn][spn]),dicCombination)\n",
    "                            \n",
    "                        elif finger0 == 4 and 0 < (fretDiff) <= 3:\n",
    "#                             print(str(dn) + \" \" + str(pn) +\" \" + str(sdn) + \" \" + str(spn) + \" \" +\"case15\")\n",
    "                            dicAppend((dn,sdn),(domains[dn][pn], domains[sdn][spn]),dicCombination)\n",
    "                            \n",
    "                    elif finger1 == 3:\n",
    "                        if finger0 == 4 and 0 < (fretDiff) <= 1:\n",
    "#                             print(str(dn) + \" \" + str(pn) +\" \" + str(sdn) + \" \" + str(spn) + \" \" +\"case16\")\n",
    "                            dicAppend((dn,sdn),(domains[dn][pn], domains[sdn][spn]),dicCombination)\n",
    "#             countComb = countComb + 1        \n",
    "#             print(countComb)\n",
    "        \n",
    "useFlag"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 144,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{(0, 1): [([6, 1, 1], [5, 3, 2]),\n",
       "  ([6, 1, 1], [5, 3, 3]),\n",
       "  ([6, 1, 1], [5, 3, 4]),\n",
       "  ([6, 1, 2], [5, 3, 4])],\n",
       " (0, 2): [([6, 1, 1], [4, 3, 2]),\n",
       "  ([6, 1, 1], [4, 3, 3]),\n",
       "  ([6, 1, 1], [4, 3, 4]),\n",
       "  ([6, 1, 2], [4, 3, 4])],\n",
       " (1, 2): [([5, 3, 1], [4, 3, 1]),\n",
       "  ([5, 3, 1], [4, 3, 2]),\n",
       "  ([5, 3, 1], [4, 3, 3]),\n",
       "  ([5, 3, 1], [4, 3, 4]),\n",
       "  ([5, 3, 2], [4, 3, 3]),\n",
       "  ([5, 3, 2], [4, 3, 4]),\n",
       "  ([5, 3, 3], [4, 3, 4]),\n",
       "  ([6, 8, 1], [5, 8, 1]),\n",
       "  ([6, 8, 1], [5, 8, 2]),\n",
       "  ([6, 8, 1], [5, 8, 3]),\n",
       "  ([6, 8, 1], [5, 8, 4]),\n",
       "  ([6, 8, 2], [5, 8, 3]),\n",
       "  ([6, 8, 2], [5, 8, 4]),\n",
       "  ([6, 8, 3], [5, 8, 4])]}"
      ]
     },
     "execution_count": 144,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# practice dicCombination\n",
    "dicCombination\n",
    "# print(dicCombination)\n",
    "# a=0\n",
    "# b=1\n",
    "# dicCombination[(a,b)][0][0]\n",
    "dicTemp = {(0, 1): [([6, 1, 1], [5, 3, 2]),\n",
    "  ([6, 1, 1], [5, 3, 3]),\n",
    "  ([6, 1, 1], [5, 3, 4]),\n",
    "  ([6, 1, 2], [5, 3, 4])],\n",
    " (0, 2): [([6, 1, 1], [4, 3, 2]),\n",
    "  ([6, 1, 1], [4, 3, 3]),\n",
    "  ([6, 1, 1], [4, 3, 4]),\n",
    "  ([6, 1, 2], [4, 3, 4])],\n",
    " (1, 2): [([5, 3, 1], [4, 3, 1]),\n",
    "  ([5, 3, 1], [4, 3, 2]),\n",
    "  ([5, 3, 1], [4, 3, 3]),\n",
    "  ([5, 3, 1], [4, 3, 4]),\n",
    "  ([5, 3, 2], [4, 3, 3]),\n",
    "  ([5, 3, 2], [4, 3, 4]),\n",
    "  ([5, 3, 3], [4, 3, 4]),\n",
    "  ([6, 8, 1], [5, 8, 1]),\n",
    "  ([6, 8, 1], [5, 8, 2]),\n",
    "  ([6, 8, 1], [5, 8, 3]),\n",
    "  ([6, 8, 1], [5, 8, 4]),\n",
    "  ([6, 8, 2], [5, 8, 3]),\n",
    "  ([6, 8, 2], [5, 8, 4]),\n",
    "  ([6, 8, 3], [5, 8, 4])]}\n",
    "dicTemp"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 143,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[([6, 1, 1], [5, 3, 2]), ([6, 1, 1], [5, 3, 3])]\n",
      "killSelf = 0\n",
      "key = (0, 1)\n",
      "killSelf in key: true\n",
      "keyComp = (0, 1)\n",
      "key == keyComp or killSelf not in keyComp, next key\n",
      "keyComp = (0, 2)\n",
      "key != keyComp and killSelf in keyComp\n",
      "killValueTuple =([6, 1, 1], [5, 3, 2])\n",
      "killValue = [6, 1, 1]\n",
      "compValueTuple =([6, 1, 1], [4, 3, 3])\n",
      "compValue = [6, 1, 1]\n",
      "\n",
      "\n",
      "killValueTuple =([6, 1, 1], [5, 3, 3])\n",
      "killValue = [6, 1, 1]\n",
      "\n",
      "\n",
      "keyComp = (1, 2)\n",
      "key == keyComp or killSelf not in keyComp, next key\n",
      "key = (0, 2)\n",
      "killSelf in key: true\n",
      "keyComp = (0, 1)\n",
      "key != keyComp and killSelf in keyComp\n",
      "killValueTuple =([6, 1, 1], [4, 3, 3])\n",
      "killValue = [6, 1, 1]\n",
      "compValueTuple =([6, 1, 1], [5, 3, 2])\n",
      "compValue = [6, 1, 1]\n",
      "\n",
      "\n",
      "killValueTuple =([6, 1, 1], [4, 3, 4])\n",
      "killValue = [6, 1, 1]\n",
      "\n",
      "\n",
      "keyComp = (0, 2)\n",
      "key == keyComp or killSelf not in keyComp, next key\n",
      "keyComp = (1, 2)\n",
      "key == keyComp or killSelf not in keyComp, next key\n",
      "key = (1, 2)\n",
      "killSelf = 1\n",
      "key = (0, 1)\n",
      "killSelf in key: true\n",
      "keyComp = (0, 1)\n",
      "key == keyComp or killSelf not in keyComp, next key\n",
      "keyComp = (0, 2)\n",
      "key == keyComp or killSelf not in keyComp, next key\n",
      "keyComp = (1, 2)\n",
      "key != keyComp and killSelf in keyComp\n",
      "killValueTuple =([6, 1, 1], [5, 3, 2])\n",
      "killValue = [5, 3, 2]\n",
      "compValueTuple =([5, 3, 2], [4, 3, 3])\n",
      "compValue = [5, 3, 2]\n",
      "\n",
      "\n",
      "killValueTuple =([6, 1, 1], [5, 3, 3])\n",
      "killValue = [5, 3, 3]\n",
      "compValueTuple =([5, 3, 2], [4, 3, 3])\n",
      "compValue = [5, 3, 2]\n",
      "compValueTuple =([5, 3, 2], [4, 3, 4])\n",
      "compValue = [5, 3, 2]\n",
      "compValueTuple =([5, 3, 3], [4, 3, 4])\n",
      "compValue = [5, 3, 3]\n",
      "\n",
      "\n",
      "key = (0, 2)\n",
      "key = (1, 2)\n",
      "killSelf in key: true\n",
      "keyComp = (0, 1)\n",
      "key != keyComp and killSelf in keyComp\n",
      "killValueTuple =([5, 3, 2], [4, 3, 3])\n",
      "killValue = [5, 3, 2]\n",
      "compValueTuple =([6, 1, 1], [5, 3, 2])\n",
      "compValue = [5, 3, 2]\n",
      "\n",
      "\n",
      "killValueTuple =([5, 3, 2], [4, 3, 4])\n",
      "killValue = [5, 3, 2]\n",
      "\n",
      "\n",
      "killValueTuple =([5, 3, 3], [4, 3, 4])\n",
      "killValue = [5, 3, 3]\n",
      "compValueTuple =([6, 1, 1], [5, 3, 2])\n",
      "compValue = [5, 3, 2]\n",
      "compValueTuple =([6, 1, 1], [5, 3, 3])\n",
      "compValue = [5, 3, 3]\n",
      "\n",
      "\n",
      "keyComp = (0, 2)\n",
      "key == keyComp or killSelf not in keyComp, next key\n",
      "keyComp = (1, 2)\n",
      "key == keyComp or killSelf not in keyComp, next key\n",
      "killSelf = 2\n",
      "key = (0, 1)\n",
      "key = (0, 2)\n",
      "killSelf in key: true\n",
      "keyComp = (0, 1)\n",
      "key == keyComp or killSelf not in keyComp, next key\n",
      "keyComp = (0, 2)\n",
      "key == keyComp or killSelf not in keyComp, next key\n",
      "keyComp = (1, 2)\n",
      "key != keyComp and killSelf in keyComp\n",
      "killValueTuple =([6, 1, 1], [4, 3, 3])\n",
      "killValue = [4, 3, 3]\n",
      "compValueTuple =([5, 3, 2], [4, 3, 3])\n",
      "compValue = [4, 3, 3]\n",
      "\n",
      "\n",
      "killValueTuple =([6, 1, 1], [4, 3, 4])\n",
      "killValue = [4, 3, 4]\n",
      "compValueTuple =([5, 3, 2], [4, 3, 3])\n",
      "compValue = [4, 3, 3]\n",
      "compValueTuple =([5, 3, 2], [4, 3, 4])\n",
      "compValue = [4, 3, 4]\n",
      "\n",
      "\n",
      "key = (1, 2)\n",
      "killSelf in key: true\n",
      "keyComp = (0, 1)\n",
      "key == keyComp or killSelf not in keyComp, next key\n",
      "keyComp = (0, 2)\n",
      "key != keyComp and killSelf in keyComp\n",
      "killValueTuple =([5, 3, 2], [4, 3, 3])\n",
      "killValue = [4, 3, 3]\n",
      "compValueTuple =([6, 1, 1], [4, 3, 3])\n",
      "compValue = [4, 3, 3]\n",
      "\n",
      "\n",
      "killValueTuple =([5, 3, 2], [4, 3, 4])\n",
      "killValue = [4, 3, 4]\n",
      "compValueTuple =([6, 1, 1], [4, 3, 3])\n",
      "compValue = [4, 3, 3]\n",
      "compValueTuple =([6, 1, 1], [4, 3, 4])\n",
      "compValue = [4, 3, 4]\n",
      "\n",
      "\n",
      "killValueTuple =([5, 3, 3], [4, 3, 4])\n",
      "killValue = [4, 3, 4]\n",
      "\n",
      "\n",
      "keyComp = (1, 2)\n",
      "key == keyComp or killSelf not in keyComp, next key\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "[[([6, 1, 1], [5, 3, 2]), ([6, 1, 1], [5, 3, 3])],\n",
       " [([6, 1, 1], [4, 3, 3]), ([6, 1, 1], [4, 3, 4])],\n",
       " [([5, 3, 2], [4, 3, 3]), ([5, 3, 2], [4, 3, 4]), ([5, 3, 3], [4, 3, 4])]]"
      ]
     },
     "execution_count": 143,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# killing each other, if doesn't exist\n",
    "listKey = []\n",
    "listVal = []\n",
    "for key, value in dicCombination.items():\n",
    "    listKey.append(key)\n",
    "    listVal.append(value)\n",
    "#     print(key)\n",
    "#     for i in key:\n",
    "#         print(i)\n",
    "#     print(value)\n",
    "# print(listKey)\n",
    "print(listVal[0])\n",
    "\n",
    "# killSelf is the Domain, which is being killed\n",
    "# killSelf = 0, 1, 2 ....\n",
    "for killSelf in range(len(domains)):\n",
    "    print(\"killSelf = \" + str(killSelf))\n",
    "    \n",
    "    # keys = (0,1), (0,2), (1,2), ...\n",
    "    # get rowIndex & tupleIndex\n",
    "    for key in listKey:\n",
    "#         for item in key:\n",
    "        print(\"key = \" + str(key))\n",
    "        rowIndex = listKey.index(key)\n",
    "        if killSelf in key:\n",
    "            print(\"killSelf in key: true\")\n",
    "            tupleIndex = key.index(killSelf)\n",
    "            \n",
    "            for keyComp in listKey:\n",
    "                print(\"keyComp = \" + str(keyComp))\n",
    "                compRowIndex = listKey.index(keyComp)\n",
    "                if key != keyComp and killSelf in keyComp:\n",
    "                    print(\"key != keyComp and killSelf in keyComp\")\n",
    "                    compTupleIndex = keyComp.index(killSelf)\n",
    "                    \n",
    "                    \n",
    "                    lastExamKillValue = 0\n",
    "                    for killValueTuple in listVal[rowIndex]:\n",
    "                        print(\"killValueTuple =\" + str(killValueTuple))\n",
    "                        killValue = killValueTuple[tupleIndex]\n",
    "                        print(\"killValue = \" + str(killValue))\n",
    "                        \n",
    "                        if killValue != lastExamKillValue:\n",
    "                            sameAsComp = 0\n",
    "                            for compValueTuple in listVal[compRowIndex]:\n",
    "                                if sameAsComp ==1:\n",
    "                                    break\n",
    "                                print(\"compValueTuple =\" + str(compValueTuple))\n",
    "                                compValue = compValueTuple[compTupleIndex]\n",
    "                                print(\"compValue = \" + str(compValue))\n",
    "                                if killValue == compValue:\n",
    "                                    sameAsComp = 1\n",
    "                            if sameAsComp ==0:\n",
    "                                listVal[rowIndex].remove(killValueTuple)\n",
    "                                print(\"remove \" + str(killValueTuple))\n",
    "                        lastExamKillValue = killValue\n",
    "        \n",
    "#                         print(\"killValue = \" + str(killValueTuple))\n",
    "                        \n",
    "#                         print(\"KillValueIndex = \" + str(listVal[rowIndex].index(killValueTuple)))\n",
    "# #                         if killValue\n",
    "#                         print(rowIndex)\n",
    "#                         print(tupleIndex)\n",
    "#                         print(killValue)\n",
    "                        print(\"\\n\")\n",
    "                \n",
    "                else:\n",
    "                    print(\"key == keyComp or killSelf not in keyComp, next key\")\n",
    "#                     break\n",
    "            \n",
    "            \n",
    "#             print(row)\n",
    "#             print(killSelf)\n",
    "#             print(key)\n",
    "#             print(index)\n",
    "#             print(\"\\n\")\n",
    "#     print(legalD)\n",
    "\n",
    "listVal"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " {(0, 1): [([6, 1, 1], [5, 3, 2]),\n",
    "           ([6, 1, 1], [5, 3, 3]),\n",
    "           ([6, 1, 1], [5, 3, 4]),\n",
    "           ([6, 1, 2], [5, 3, 4])],\n",
    " (0, 2):  [([6, 1, 1], [4, 3, 2]),\n",
    "           ([6, 1, 1], [4, 3, 3]),\n",
    "           ([6, 1, 1], [4, 3, 4]),\n",
    "           ([6, 1, 2], [4, 3, 4])],\n",
    " (1, 2):  [([5, 3, 1], [4, 3, 1]),\n",
    "           ([5, 3, 1], [4, 3, 2]),\n",
    "           ([5, 3, 1], [4, 3, 3]),\n",
    "           ([5, 3, 1], [4, 3, 4]),\n",
    "           ([5, 3, 2], [4, 3, 3]),\n",
    "           ([5, 3, 2], [4, 3, 4]),\n",
    "           ([5, 3, 3], [4, 3, 4]),\n",
    "           ([6, 8, 1], [5, 8, 1]),\n",
    "           ([6, 8, 1], [5, 8, 2]),\n",
    "           ([6, 8, 1], [5, 8, 3]),\n",
    "           ([6, 8, 1], [5, 8, 4]),\n",
    "           ([6, 8, 2], [5, 8, 3]),\n",
    "           ([6, 8, 2], [5, 8, 4]),\n",
    "           ([6, 8, 3], [5, 8, 4])]}\n",
    "           \n",
    "           \n",
    "listKey = [ (0, 1),\n",
    "            (0, 2),\n",
    "            (1, 2)]\n",
    "            \n",
    "listValue = [ \n",
    "                [(   ,   ), (    ,    ), ........],\n",
    "                [(  ,   ), (    ,    ), ........],\n",
    "                [(  ,   ), (    ,    ), ........],\n",
    "            ]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 133,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[[1], [2], [3], [4]], [[5, 6], [7, 8], [9, 0], [11, 12, 13]]]\n",
      "[[[1], [2], [3], [4]], [[5, 6], [9, 0], [11, 12, 13]]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "[[[1], [2], [3], [4]],\n",
       " [[5, 6], [9, 0], [11, 12, 13]],\n",
       " [[666], [555], [444], [333, 222, 111]]]"
      ]
     },
     "execution_count": 133,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# practice \"del\" usage in list\n",
    "lista =[[[1],[2],[3],[4]], [[5,6],[7,8],[9,0],[11,12,13]]]\n",
    "print(lista)\n",
    "del lista[1][1] # del address\n",
    "print(lista)\n",
    "lista.append([[666],[555],[444],[333,222,111]])\n",
    "lista"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 134,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[[1], [2], [3], [4]], [[5, 6], [7, 8], [9, 0], [11, 12, 13]]]\n",
      "[[[1], [2], [3], [4]], [[5, 6], [7, 8], [9, 0], [11, 12, 13]]]\n",
      "[[[1], [2], [3], [4]], [[5, 6], [7, 8], [9, 0], [11, 12, 13]], [[666], [555], [444], [333, 222, 111]]]\n",
      "0\n",
      "1\n",
      "if\n",
      "[[[1], [2], [3], [4]], [[5, 6], [9, 0], [11, 12, 13]], [[666], [555], [444], [333, 222, 111]]]\n",
      "2\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "[[[1], [2], [3], [4]],\n",
       " [[5, 6], [9, 0], [11, 12, 13]],\n",
       " [[666], [555], [444], [333, 222, 111]]]"
      ]
     },
     "execution_count": 134,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# practice \"remove\" usage in list\n",
    "lista =[[[1],[2],[3],[4]], [[5,6],[7,8],[9,0],[11,12,13]]]\n",
    "print(lista)\n",
    "# del lista[1][1]\n",
    "print(lista)\n",
    "lista.append([[666],[555],[444],[333,222,111]])\n",
    "print(lista)\n",
    "for row in range(len(lista)):\n",
    "    item = 0\n",
    "    print(row)\n",
    "    while item in range(len(lista[row])):\n",
    "        if lista[row][item] == [7,8]:\n",
    "            print(\"if\")\n",
    "            lista[row].remove(lista[row][item]) # .remove([7,8])\n",
    "            print(lista)\n",
    "        item = item + 1\n",
    "lista"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2\n"
     ]
    }
   ],
   "source": [
    "# practice \"if condition\"\n",
    "a=2\n",
    "b=1\n",
    "c=0\n",
    "if b<a>c:\n",
    "    print(a)\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
